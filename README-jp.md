# 🎓 FPGA 上のハードウェアおよび SoC システム設計 – レベル 0 (Kria KV260)

**FPGA 上の SoC ハードウェアおよびシステム設計** シリーズの **レベル 0** へようこそ。
このリポジトリには、シンプルなハードウェア モジュールの実装と、それをボード上の **Xilinx Kria KV260** SoC システムに統合するためのすべてのドキュメント、ソース コード、および手順が含まれています。

---
# 詳細なビデオの説明

手順については、以下の対応するビデオ チュートリアルで詳しく説明します。各手順を詳しく見るには、以下のビデオをクリックしてください 👇👇👇。

[![デモビデオを見る](https://img.youtube.com/vi/F1vxzkd7_DI/0.jpg)](https://www.youtube.com/watch?v=F1vxzkd7_DI)

または、次のリンクにアクセスしてください: https://youtu.be/F1vxzkd7_DI?si=RyHPx3zzii_RXPgk
---

## I. アルゴリズムの要件

このレベル 0 では、基本的な数学関数を実装します。

> **Y = A × X + B**

オペランド A、X、B、および結果 Y には、固定小数点標準 Q15.16 (1 ビット符号、15 ビット整数表現、16 ビット 10 進表現) を使用します。

- 設計は Verilog HDL 言語で記述し、有限ステート マシン (FSM) を介して制御し、Start、Done、Valid 制御信号を使用して SoC システムに統合する必要があります。

- 独自設計の IP と CPU 間の通信は PIO (Programmed I/O) を介して行われます。つまり、CPU は値 A、X、B を IP の制御レジスタに直接書き込み、結果 Y もレジスタを介して読み取ります。 PIO はシンプルで実装しやすい通信方法ですが、CPU の処理時間を消費するため、高速データ転送には適していません。


⚠️注: これはレベル 0 設計であり、単純な PIO 方式のみを使用し、DDRAM メモリから独自設計の IP への DMA 転送メカニズムを統合していません。データ転送パフォーマンスを向上させるために、次のレベルでは DMA が検討される予定です。


このコースは、FPGA ベースの SoC システム開発の初心者向けに設計されています。

---

## II.不可欠

### A. デバイスのリスト:
以下は、**Kria KV260 FPGA** ボードでレベル 0 を練習するために必要なハードウェアのリストです。

![必要な機材](Picture/Picture_1.png)

- **Kria KV260 FPGA**: SoC システムを展開し、組み込みアプリケーションを実行するために使用されるメインボード。

- **ネットワーク ケーブル (LAN)**: ルーター/スイッチ経由で FPGA をインターネットに接続するために使用され、SSH 経由の更新とデバッグをサポートします。

- **JTAG ケーブル**: FPGA からサーバー PC に接続してビットストリームをロードしたり、デバッグしたり、FPGA 上に Linux コンソールを表示するための UART ケーブルとして機能します。

- **MicroSD カードとカード リーダー**: ブート イメージ (BOOT.BIN + Linux カーネル + rootfs) を作成し、FPGA のオペレーティング システムをインストールするために使用されます。

- **サーバー PC (Linux)**: ハードウェア設計ツール (Vivado)、PetaLinux ツールをインストールし、完全なシステム ビルドを実行します。

- **個人用ラップトップ/PC (Windows または Linux)**: サーバーに SSH で接続したり、ファイルを転送したりするために使用します (WinSCP)。 Windows を使用する場合は、Linux を実行するために **VMware** をインストールする必要があります。

⚠️ **注:** PetaLinux をインストールするためにマシンに Linux がインストールされていれば、**1 台のサーバー PC と 1 台のラップトップ/PC** を **1 台の単一のラップトップ/PC** に置き換えることができます。

### B. デバイスの接続

ハードウェア設計プロセスを開始する前に、次のデバイスを接続してセットアップする必要があります。

- **KV260 FPGA**: **ネットワーク ケーブル** を介してルーターに接続してインターネットに接続し、**JTAG ケーブル** を介してサーバー PC に接続してビットストリームをロードし、デバッグします。
- **サーバー PC**: **Vivado** と **Petalinux** をインストールし、ネットワークとメモリ カード リーダーに接続して FPGA 用に Linux を準備するために使用します。
- **ラップトップ**: **SSH 接続** (MobaXterm、VSCode、またはターミナル経由) を介してサーバー PC と KV260 を制御するために使用されます。

⚠️ **注意**:
- サーバー PC とラップトップは同じ内部ネットワーク (LAN/WiFi) 上にある必要があります。
- microSD カードは、Linux オペレーティング システムを FPGA にロードするために使用されます。

<p align="center">
<img src="Picture/Picture_2.png" alt="デバイスを接続" width="600"/>
</p>

---

## III.設計プロセスのステップごとの詳細

<p align="center">
<img src="Hinh/Hinh_Quy_Trinh.png" alt="設計プロセス" width="600"/>
</p>

FPGA 上の SoC システム設計プロセスは、要件の定義と Verilog を使用したハードウェアの記述から始まり、IP パッケージ化、Vivado でのシステム設計、PetaLinux のセットアップ、そして最後に設計されたハードウェアを制御する組み込みソフトウェアの開発まで、8 つの連続したステップで構成されます。

次に、上記の 8 つの手順を詳しく説明します。

### A. ステップ1: システム要件と仕様を決定する（ブロック図を描く）

- 実装する関数: **Y = A × X + B**、**固定小数点 Q15.16** 標準数 (符号ビット 1 個、整数ビット 15 個、小数ビット 16 個) を使用します。
- 乗算、加算、レジスタ ブロックで構成され、**FSM (有限状態マシン)** によって制御されるブロック ダイアグラムを構築します。
- FSM は、`IDLE`、`EXECUTE`、`WAIT_DONE` の 3 つの状態で構成され、`Start_in` および `Done_in` 信号によって制御されます。

📌 メインシグナル:
`A_in`、`X_in`、`B_in`（入力）、`Y_out`、`Valid_out`（出力）、`Start_in`、`Done_in`（制御）

![ブロック図](Picture/Picture_3.png)

### B. ステップ2: ハードウェア設計を記述し、機能をシミュレートする

- オペランドに **固定小数点 Q15.16** 標準を使用して **Y = A × X + B** の計算を実行するデジタル回路を記述する **Verilog HDL** コードを記述します。
- **RTL Verilog ソース コード** は次のディレクトリにあります:
- `RTL/MAC.v`

- 実際の値を使用して **10 個のテスト ケース** をシミュレートする **テストベンチ** を作成し、出力 `Y_out` が期待値と一致するかどうかを確認します。 **Vivado シミュレータ** を使用してシミュレーションを実行し、次の点を確認します。
- 波形上の信号波形
- 計算結果がコンソールウィンドウに出力されます（各テストケースの合否）

- **テストベンチのソースコード**は次のディレクトリにあります:
- `TB/TB_MAC.v`

- シミュレーション用に事前構成された**プロジェクト Vivado (2022.2)** は次のフォルダーにあります。
- `シミュレーション/`

<p align="center">
<img src="Picture/Picture_4.png" alt="Vivado でのシミュレーション" width="700"/>
</p>

### C. ステップ3: VivadoでIPをパッケージ化する

**Verilog HDL** を使用してハードウェアを記述し、シミュレーションに成功したら、**設計を IP にパッケージ化** して、次のステップで再利用し、SoC システムに統合できるようにします。

下の図は、**カスタム IP (`MY_IP`)** が SoC システムに統合され、**AXI4 バス** を介して CPU に接続される様子を示しています。回路の入出力信号 (`A_in`、`X_in`、`B_in`、`Start_in`、`Done_in`) は、`AXI4 Mapping` クラスを介して AXI4-Full インターフェイスにマッピングされます。

<p align="center">
<img src="Hinh/Hinh_MY_IP.png" alt="SoCシステムへのMY_IPの統合図" width="750"/>
</p>

- 次のフォルダー内の **AXI4-Full を含むバス システム** に関するコンテンツを参照してください。
- `Reference_Document/Bus_System.pdf`

実行する手順:

1. Vivadoを開き、メニュー**ツール→新しいIPの作成とパッケージ**を選択します。
2. IPタイプを選択: 利用可能なRTLコードから(`現在のプロジェクトをパッケージ化`)
3. IPの識別情報を入力します。
- IP名 (`MY_IP`)
- バージョン（例：`1.0`）
- 機能説明（FSM制御による積和演算コア）
4. I/O信号ポートと通信アドレスを設定します。
- CPUとの通信に使用する場合、**AXI4-Full** 標準による信号マッピング
5. すべての設定を再度確認する
6. **Package IP** をクリックして、この IP をパッケージ化し、Vivado IP カタログに追加します。

> これは、ブロック デザインで IP を再利用できるようにするために必要な手順です。

![図 5 - IP カプセル化インターフェース](図/Figure_5.png)

### D. ステップ4: VivadoでSoCシステムのブロックデザインを作成する

IP のパッケージ化が正常に完了したら、Vivado の **ブロック デザイン** を使用して SoC システムの作成に進みます。

ブロック設計図の主なコンポーネント:

- **ZYNQ MPSoC**: システム、ピン構成、AXI 接続を制御するメイン プロセッサ。
- **カスタム IP (MY_IP_v1_0)**: MAC 関数 `Y = A * X + B` が含まれており、**AXI4-Full** 標準を介して接続されています。
- **AXI SmartConnect**: AXI プロトコルを使用してマスター/スレーブ間をブリッジします。
- **リセット モジュール**: 処理部とプログラミング部の間でリセット信号を同期します。

#### Vivado で実行する操作:

1. **IP Integrator** メニューから **新しいブロック デザイン** を作成します。
2. 主要コンポーネント (ZYNQ MPSoC、MY_IP_v1_0、AXI SmartConnect、リセット) を回路図に追加します。
3. **Run Block Automation** を使用して ZYNQ を自動的に構成します。
4. AXI ポートとリセット ポートを適切に接続します。

<p align="center">
<img src="Picture/Picture_6.png" alt="ブロック設計SoC" width="750"/>
</p>

### E. ステップ 5: 合成、配置配線、ビットストリーム ファイルの作成

接続図を完成したら:

1. **ブロック デザインを右クリック** → **「出力製品の生成」** を選択します。
2. **もう一度右クリック** → **「HDL ラッパーの作成」** を選択して、デザインのトップレベル コードを生成します。
3. 最後に、**「ビットストリームを生成」** を押して、手順全体を実行します。
- 合成
- 実装
- ビットストリーム生成（FPGA構成ファイルの作成）

> これは、デザインを FPGA にロードできる `.bit` 構成ファイルと、FPGA に Petalinux をインストールするための `.xsa` ファイルに変換するための重要なステップです。

### F. ステップ6: PetaLinux環境をセットアップしてドライバーを作成する

ハードウェア設計を完了し、Vivado でブロック デザインを作成したら、次のステップでは、**ハードウェア ファイル (`.xsa`) をエクスポート** して PetaLinux で使用し、システムに適切なオペレーティング システムとドライバーを作成します。

#### 1. Vivadoからハードウェアファイル（`.xsa`）をエクスポートする

- Vivado では、**ビットストリーム生成** が正常に実行された後、次のようになります。
- メニューへ移動: **ファイル → エクスポート → ハードウェアのエクスポート**
- 選択: ビットストリームを含める
- `.xsa` ファイルが生成されます (例: `SoC_wrapper.xsa`)

#### 2. PetaLinux をインストールする

- Xilinx の公式 Web サイトから **PetaLinux 2022.2** インストーラーをダウンロードします。
🔗 https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/embedded-design-tools/archive.html


##### 依存関係をインストールする (Ubuntu/Debian)

バッシュ
sudo apt-get install tofrodos gawk xvfb git libncurses5-dev tftpd zlib1g-dev zlib1g-dev:i386 \
libssl-dev flex bison chrpath socat autoconf libtool texinfo gcc-multilib\
libsdl1.2-dev libglib2.0-dev screen pax libtinfo5 xterm build-essential net-tools
「」

##### `.run` ファイルに実行権限を付与する

バッシュ
chmod +x petalinux-v2022.2-*.run
「」

##### インストーラーを実行する

バッシュ
./petalinux-v2022.2-*.run
「」

- インストール プロセス中に、インストーラーによってライセンス契約が表示されます。
- PgUp / PgDnを使用して読みます
- 表示を終了するにはqを押します
- 同意して続行するにはyを押してください

#### 3. ハードウェア環境の構築

##### Petalinux デスクトップ環境の設定

##### `petalinux-*` コマンドを使用するには、**Source** を Petalinux インストール ディレクトリに移動します。
バッシュ
ソース <petalinux_install_path>/2022.2/settings.sh
「」

##### Xilinx 公式サイトから KV260 FPGA 用の BSP インストーラーをダウンロードします。
🔗 https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/embedded-design-tools/archive.html

##### BSP から PetaLinux プロジェクトを作成する
バッシュ
petalinux-create -t​​ ​​project -s <BSPファイルへのパス>.bsp --name KV260_Linux
cd KV260_Linux
「」

##### ハードウェア (.xsa) をプロジェクトにインポートする Vivado から .xsa ファイル (ビットストリームを含む) をエクスポートした後、次のコマンドを使用してハードウェアをプロジェクトに統合します。
バッシュ
petalinux-config --get-hw-description=<ハードウェア記述ファイルへのパス>
「」
##### カーネルの bootargs を手動で構成します。petalinux-config を実行すると、システムは curses インターフェイスを開き、さらに構成できるようになります。カーネル bootargs 構成を調整する 構成ウィンドウで、次の操作を行います。

```テキスト
サブシステム自動ハードウェア設定 --->
DTG設定 --->
カーネルブート引数 --->
[ ] ブート引数を自動的に生成する
（ユーザー定義）ユーザー設定のカーネルブート引数
「」

次の bootargs を user set kernel bootargs セクションに貼り付けます。
バッシュ
earlycon コンソール=ttyPS1,115200 ルート=/dev/mmcblk1p2 rw rootwait cpuidle.off=1 uio_pdrv_genirq.of_id=generic-uio clk_ignore_unused init_fatal_sh=1 cma=256M
「」
📌 この構成は、デバイスを適切に起動し、UIO ドライバーを有効にし、CMA メモリ領域を割り当て、PL 内のカスタム IP のクロックを維持するのに役立ちます。

##### デバイスツリーの編集 (system-user.dtsi)

Linux オペレーティング システムで `uio` ドライバーを介して **PL 内のカスタム IP** を使用するには、**デバイス ツリー オーバーレイ** ファイルを編集する必要があります。
パス `KV260_Linux/project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dtsi` にあるファイルを次のように編集します。
```dts
/include/ "system-conf.dtsi"
/ {
アンバ_pl@0 {
MY_IP@a0000000 {
互換性 = "generic-uio";
};
};
};
「」
サンプルの `system-user.dtsi` ファイルは、github の `KV260_Linux` ディレクトリに保存されています。

##### プロジェクトをビルドします

バッシュ
petalinuxビルド
「」

### G. ステップ7: SoC FPGA上にLinux用のブートイメージとルートファイルシステムを作成する

プロジェクトを正常にビルドした後、このコマンドを入力して、ブート ファイル BOOT.BIN とシステムに適した U-Boot をパッケージ化します。

バッシュ
petalinux-package --boot --force --u-boot
「」

次に、SD カードを PC に接続し、SD カードのパーティション分割とフォーマットに進みます。 **上記のビデオチュートリアルの **53:40 から 1:03:18** までの詳細な手順については、以下のリンクをご覧ください。

📥 [Debian rootfs ファイルをここからダウンロード](https://drive.google.com/file/d/1ZcJYuVHpn8ER11nLCjwCUjfc5ykqP0tM/view?usp=sharing)

> この rootfs ファイルには、ARM64 アーキテクチャ用に事前設定された Debian オペレーティング システムが含まれており、XFCE インターフェイスをサポートし、`apt` を使用して追加のアプリケーションを簡単にインストールできます。

### H. ステップ8: 組み込みソフトウェア開発 (組み込みC/C++)


FPGA 上で Linux オペレーティング システムを完全に準備した後、**C/C++** 言語で独自に設計した IP 制御組み込みプログラムを実行します。

#### コードフォルダ
この GitHub リポジトリの `Embedded_C_Code` フォルダには、PIO インターフェイスを介して IP MAC を制御する C ソース コード全体が含まれています。

#### 実行方法

1. **WinSCP** ソフトウェアを開き、パソコンから **KV260 FPGA** ボードに接続します (SSH 経由)。
2. **このリポジトリの `Embedded_C_Code`** フォルダ全体を KV260 の `/home/debian/` フォルダにコピーします。
3. ターミナル(またはMobaXterm経由)で、コピーしたフォルダにアクセスします。
バッシュ
ssh debiang@<KV260 FPGA IPアドレス> (例 192.168.1.10)
cd 組み込みCコード
sh 実行.sh
「」
---

# 📬 このプロジェクトの実装時にコメントやエラーを解決するには、次の連絡先にお問い合わせください。

- フェイスブック: [https://www.facebook.com/pham.luan.921/](https://www.facebook.com/pham.luan.921/)
- 電子メール: [luanph@uit.edu.vn](mailto:luanph@uit.edu.vn)

いつもお付き合い、応援していただき、本当にありがとうございます🙏
**FPGA を楽しく学びましょう!**

私が共有するコンテンツが**学習や研究に役立ち、実用的で価値がある**と感じた場合は、少し**サポート**していただくと、より質の高い続編を作成するモチベーションが上がります。

👉 **注:** あなたが**学生**である場合、私はあなたからの**経済的支援を期待していません**。
しっかり勉強して、レッスンを理解し、それを必要とする人に知識を広めていただければ、私はとても幸せです! 💙

---























